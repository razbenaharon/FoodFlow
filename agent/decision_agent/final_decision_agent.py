# final_decision_agent.py
# Final Decision Agent (single target recipe, human-ish randomness) — with rich reasons
# -----------------------------------------------------------------------------
# This agent performs the final step in the decision-making process.
# Its primary responsibilities are:
# 1. To select exactly ONE recipe to cook from a list of best-matching candidates.
#    The selection process is not purely greedy; it uses a softmax function with a
#    "temperature" parameter to introduce human-like variability.
# 2. To assign a final action (COOK, SELL, or DONATE) to EVERY expiring ingredient.
# 3. To generate and output rich, human-readable reasons for each group of actions,
#    explaining the "why" behind the decision based on multiple signals like
#    ingredient expiry, recipe rank, marketability, and restaurant data.
# 4. To save the detailed per-ingredient decisions to a JSON file.

from __future__ import annotations

import json
import math
import os
import random
import re
import unicodedata
from pathlib import Path
from typing import Dict, List, Set, Tuple, Any, Optional

# ── Paths ──────────────────────────────────────────────────────────────────────
# Define key file paths relative to the project structure.
PROJECT_ROOT = Path(__file__).resolve().parents[2]
RESULTS_DIR = PROJECT_ROOT / "results"
RECIPES_DIR = RESULTS_DIR / "recipes"

# Input files: these are dependencies generated by previous agents.
BEST_RECIPES_FILE = RECIPES_DIR / "best_matching_recipes.json"
EXPIRING_FILE = PROJECT_ROOT / "data" / "expiring_ingredients.json"
TOP_RESTAURANTS_FILE = RESULTS_DIR / "top_restaurants.json"
DONATION_FILE = RESULTS_DIR / "best_soup_kitchen.json"
REPLY_TABLE_FILE = RESULTS_DIR / "learning" / "top_restaurants_by_reply.json"  # Learned data source

# Output file: this is the final result of this agent.
OUTPUT_FILE = RESULTS_DIR / "final_decision_output.json"

# ── Behavior knobs (tweak to taste or via env) ────────────────────────────────
# These parameters control the agent's behavior and can be set via environment variables.
# Controls the randomness of recipe selection. 0.3 is more greedy (almost always picks the best).
# 1.2 is more exploratory and might pick a lower-ranked but still good recipe.
HUMAN_TEMPERATURE = float(os.getenv("FOODFLOW_TEMPERATURE", "0.9"))
# If set to a number, ensures the random choices are the same every run, for reproducibility.
SEED_ENV = os.getenv("FOODFLOW_SEED")
# The probability that a leftover (not cooked) ingredient is assigned to SELL vs. DONATE.
LEFTOVER_SELL_PROB = float(os.getenv("FOODFLOW_SELL_PROB", "0.7"))

# ── Random instance (optionally seeded) ────────────────────────────────────────
_rng = random.Random()
if SEED_ENV is not None:
    try:
        # Seed the random number generator for deterministic behavior if a seed is provided.
        _rng.seed(int(SEED_ENV))
    except (ValueError, TypeError):
        # Fallback for non-integer seeds.
        _rng.seed(SEED_ENV)


# ── Helpers ────────────────────────────────────────────────────────────────────
def _norm(s: str) -> str:
    """
    Normalizes a string by converting it to lowercase, removing accents, and collapsing whitespace.
    This is crucial for consistent, case-insensitive matching of ingredient names.
    Example: "  Crème Fraîche " -> "creme fraiche"
    """
    s = unicodedata.normalize('NFKD', s or "").encode('ascii', 'ignore').decode('ascii')
    return re.sub(r'\s+', ' ', s.lower()).strip()


def _canonicalize_list(values: List[str]) -> List[str]:
    """
    Deduplicates a list of strings based on their normalized form,
    preserving the original casing and form of the first occurrence.
    """
    seen: Set[str] = set()
    out: List[str] = []
    for v in values:
        if not isinstance(v, str):
            continue
        key = _norm(v)
        if key and key not in seen:
            seen.add(key)
            out.append(v.strip())
    return out


def _load_json(path: Path) -> Any:
    """Safely loads a JSON file with UTF-8 encoding."""
    with open(path, encoding="utf-8") as f:
        return json.load(f)


def _safe_get_days(meta_row: Dict[str, Any]) -> Optional[float]:
    """
    Safely extracts the 'days_to_expire' value from a dictionary,
    handling potential missing keys or type conversion errors.
    """
    d = meta_row.get("days_to_expire")
    try:
        return float(d) if d is not None else None
    except (ValueError, TypeError):
        return None


def _expiring_universe() -> Tuple[List[str], Dict[str, str]]:
    """
    Loads the list of expiring ingredients from the source file.
    Returns a tuple containing:
    1. A deduplicated list of original (canonical) ingredient names.
    2. A mapping from the normalized name to the canonical name (e.g., "sea bass" -> "Sea Bass").
    """
    universe: List[str] = []
    if EXPIRING_FILE.exists():
        raw = _load_json(EXPIRING_FILE)
        for row in raw:
            # Handle different possible JSON structures (dict with 'item'/'name', or just a string)
            nm = (row.get("item") if isinstance(row, dict) else None) or (
                row.get("name") if isinstance(row, dict) else None)
            if not nm and isinstance(row, str):
                nm = row
            if isinstance(nm, str) and nm.strip():
                universe.append(nm.strip())
    # Ensure the list is unique based on normalized names
    universe = _canonicalize_list(universe)
    # Create the mapping for easy lookup
    canon_by_norm = {_norm(x): x for x in universe}
    return universe, canon_by_norm


def _expiring_meta_map() -> Dict[str, Dict[str, Any]]:
    """
    Creates a dictionary mapping each normalized ingredient name to its metadata
    (e.g., days_to_expire, quantity, unit). This is used for crafting richer reasons.
    """
    meta: Dict[str, Dict[str, Any]] = {}
    if not EXPIRING_FILE.exists(): return meta
    for row in _load_json(EXPIRING_FILE):
        if not isinstance(row, dict): continue
        nm = (row.get("item") or row.get("name") or "").strip()
        if not nm: continue
        # Accommodate various possible key names for metadata fields
        meta[_norm(nm)] = {
            "days_to_expire": row.get("days_to_expire") or row.get("days") or row.get("expires_in_days"),
            "quantity": row.get("quantity"),
            "unit": row.get("unit"),
        }
    return meta


def _softmax_sample(weights: List[float], temperature: float, rng: random.Random) -> int:
    """
    Selects an index from a list of weights using softmax sampling.
    This allows for weighted random selection instead of always picking the max.
    - temperature <= 0: Greedy mode, always returns the index of the maximum weight.
    - temperature > 0: Probabilistic mode. Higher temp = more random, lower temp = more greedy.
    """
    if temperature <= 0:
        # Greedy selection: return the index of the highest weight.
        return max(range(len(weights)), key=lambda i: weights[i])

    # Scale weights by temperature.
    scaled = [w / temperature for w in weights]
    m = max(scaled) if scaled else 0.0
    # Use exp-normalize trick to avoid floating point overflow issues.
    exps = [math.exp(x - m) for x in scaled]
    s = sum(exps) or 1.0
    probs = [x / s for x in exps]

    # Sample an index based on the calculated probabilities.
    r = rng.random()
    cum = 0.0
    for i, p in enumerate(probs):
        cum += p
        if r <= cum:
            return i
    return len(probs) - 1


def _select_one_recipe(best: List[Dict[str, Any]], expiring_norms: Set[str],
                       rng: random.Random, temperature: float) -> Optional[Dict[str, Any]]:
    """
    Selects exactly one recipe from the list of candidates using a weighted scoring model
    and softmax sampling. The score is a combination of ingredient coverage and recipe rank.
    """
    if not best: return None

    # Calculate coverage (how many expiring ingredients each recipe uses) and rank for all candidates.
    coverages, ranks = [], []
    for rec in best:
        cov = {_norm(x) for x in (rec.get("matched_expiring") or []) if isinstance(x, str)}
        coverages.append(len(expiring_norms & cov))
        ranks.append(int(rec.get("rank", 9999)))

    # Normalize coverage and rank to be on a similar scale (0-1).
    max_cov = max(coverages) if coverages else 1
    max_rank = max(ranks) if ranks else 1
    max_cov = max(1, max_cov);
    max_rank = max(1, max_rank)  # Avoid division by zero

    weights = []
    for cov, rk in zip(coverages, ranks):
        cov_norm = cov / max_cov
        # Higher rank (lower number) should result in a higher score.
        rank_norm = 1.0 - (rk - 1) / (max_rank - 1) if max_rank > 1 else 1.0
        # Combine scores with a defined weighting. 75% coverage, 25% rank.
        base = 0.75 * cov_norm + 0.25 * rank_norm
        # Add a small amount of random noise to break ties and add variability.
        weights.append(base + rng.uniform(-0.05, 0.05))

    # Use softmax sampling to pick the final recipe based on the calculated weights.
    idx = _softmax_sample(weights, temperature=temperature, rng=rng)
    return best[idx] if 0 <= idx < len(best) else None


def _pick_targets_and_reply_prob() -> Tuple[Optional[Dict[str, Any]], Optional[str], Optional[float]]:
    """
    Determines the target restaurant to SELL to and its expected reply probability.
    It prioritizes the learned reply probabilities from `REPLY_TABLE_FILE` if available,
    as this is considered the source of truth.
    Returns:
      - The full data entry for the top restaurant.
      - The name of the top restaurant.
      - The expected reply probability.
    """
    sell_entry = None
    sell_name, reply_prob = None, None

    # Step 1: Load the top restaurant from the generic results file.
    if TOP_RESTAURANTS_FILE.exists():
        try:
            top = _load_json(TOP_RESTAURANTS_FILE)
            if isinstance(top, list) and top:
                sell_entry = top[0]
            elif isinstance(top, dict):
                # Handle various possible JSON structures.
                for key in ["restaurants", "top", "results", "items", "matches"]:
                    arr = top.get(key)
                    if isinstance(arr, list) and arr:
                        sell_entry = arr[0];
                        break
                if not sell_entry:
                    sell_entry = top
        except Exception:
            sell_entry = None

    if isinstance(sell_entry, dict):
        sell_name = (sell_entry.get("name") or sell_entry.get("title") or "").strip() or None
        # Use the reply probability embedded in the file, if it exists.
        rp = sell_entry.get("expected_reply_prob")
        try:
            reply_prob = float(rp) if rp is not None else None
        except (ValueError, TypeError):
            reply_prob = None

    # Step 2: Overwrite with the more accurate "learned" probability if available.
    # This file is the source of truth, updated from real-world interaction data.
    if sell_name and REPLY_TABLE_FILE.exists():
        try:
            table = _load_json(REPLY_TABLE_FILE)
            # Create a lookup map by normalized restaurant name.
            by = {(_norm(r.get("name", ""))): r for r in table if isinstance(r, dict)}
            row = by.get(_norm(sell_name))
            if row and "expected_reply_prob" in row:
                # Update the reply probability with the learned value.
                reply_prob = float(row["expected_reply_prob"])
        except Exception:
            pass  # Ignore errors, just use the previous value.

    return sell_entry, sell_name, reply_prob


def _build_decisions_single_recipe(
        expiring_universe: List[str],
        canon_by_norm: Dict[str, str],
        selected: Optional[Dict[str, Any]],
        sell_target: Optional[str],
        donate_target: Optional[str],
        rng: random.Random,
) -> List[Dict[str, Any]]:
    """
    Generates the per-ingredient action list (COOK, SELL, DONATE).
    - If an ingredient is used in the selected recipe, its action is COOK.
    - Otherwise, a random choice is made between SELL and DONATE based on `LEFTOVER_SELL_PROB`.
    """
    selected_title = (selected or {}).get("title", "").strip() if selected else ""
    # Get normalized names of ingredients used in the chosen recipe.
    selected_norms = {_norm(x) for x in ((selected or {}).get("matched_expiring") or []) if isinstance(x, str)}
    expiring_norms = {_norm(x) for x in expiring_universe}
    # Ensure we only consider cooking items that are actually on the expiring list.
    selected_norms &= expiring_norms

    decisions: List[Dict[str, Any]] = []
    for item in expiring_universe:
        k = _norm(item)
        if selected and k in selected_norms:
            # This item is used in the chosen recipe.
            decisions.append({
                "item": canon_by_norm.get(k, item),
                "action": "COOK",
                "reason": f"Used in selected recipe '{selected_title}'.",
                "target_recipes": [selected_title],
            })
        else:
            # This is a leftover item. Decide whether to sell or donate.
            if sell_target and rng.random() < LEFTOVER_SELL_PROB:
                decisions.append({
                    "item": canon_by_norm.get(k, item),
                    "action": "SELL",
                    "reason": f"Better matched to {sell_target}'s menu and demand window.",
                    "target_restaurants": [sell_target],
                })
            else:
                decisions.append({
                    "item": canon_by_norm.get(k, item),
                    "action": "DONATE",
                    "reason": "Short shelf-life / lower marketability today; donation reduces waste.",
                    "donation_center": donate_target or "Local soup kitchen",
                })
    return decisions


# —— Group reason builders (richer, multi-signal) ————————————————
# These functions generate high-level summary reasons for each action group.

def _split_by_days(items: List[str], meta: Dict[str, Dict[str, Any]]) -> Tuple[List[str], List[str], List[str]]:
    """
    Categorizes a list of items into three buckets based on their expiry date:
    (<=1 day, 2–3 days, >3 days).
    """
    soon, mid, long = [], [], []
    for it in items:
        d = _safe_get_days(meta.get(_norm(it), {}))
        if d is None:
            mid.append(it)  # Treat unknown expiry as medium risk.
        elif d <= 1:
            soon.append(it)
        elif d <= 3:
            mid.append(it)
        else:
            long.append(it)
    return soon, mid, long


def _pick_examples(items: List[str], n: int = 3) -> List[str]:
    """Returns the first `n` items from a list as examples, for concise reasons."""
    return items[:n]


def _intersect_with_sell_matches(sell_items: List[str], sell_entry: Optional[Dict[str, Any]]) -> List[str]:
    """
    Finds which of the items designated for selling were explicitly listed as
    'matched_ingredients' by the target restaurant. This provides a strong signal for the reason.
    """
    if not sell_entry: return []
    matched = set(_norm(x) for x in (sell_entry.get("matched_ingredients") or []) if isinstance(x, str))
    out = []
    for it in sell_items:
        if _norm(it) in matched:
            out.append(it)
    return out


def _group_reason_cook(selected: Optional[Dict[str, Any]], cook_items: List[str],
                       meta: Dict[str, Dict[str, Any]]) -> str:
    """Constructs a summary reason for the COOK action."""
    if not selected:
        return "No recipe selected; nothing to cook."

    title = (selected.get("title") or "").strip()
    rank = selected.get("rank")
    soon, _, _ = _split_by_days(cook_items, meta)
    used_preview = ", ".join(_pick_examples(cook_items, 3)) if cook_items else "none"

    # Assemble the reason from different pieces of information.
    bits = [f"picked '{title}'"]
    if isinstance(rank, int):
        bits.append(f"(rank #{rank})")
    if cook_items:
        bits.append(f"to convert {len(cook_items)} expiring items into menu value ({used_preview})")
    if soon:
        bits.append(f"including {len(soon)} due ≤1 day")
    return " ".join(bits) + "."


def _group_reason_sell(
        sell_items: List[str],
        sell_target: Optional[str],
        sell_entry: Optional[Dict[str, Any]],
        reply_prob: Optional[float],
        meta: Dict[str, Dict[str, Any]],
) -> str:
    """Constructs a summary reason for the SELL action."""
    if not sell_items:
        return "No items selected to sell."

    soon, mid, long = _split_by_days(sell_items, meta)
    # Check for direct overlap with the restaurant's stated needs.
    menu_overlap = _intersect_with_sell_matches(sell_items, sell_entry)

    tgt = sell_target or "the top nearby restaurant"
    bits = [f"sending {len(sell_items)} items to {tgt}"]

    # Explain *why* these items are being sold.
    if long or mid:
        bits.append(f"because {len(mid) + len(long)} item(s) have ≥2 days left")
    if menu_overlap:
        bits.append(f"and their menu matches items like {', '.join(_pick_examples(menu_overlap, 3))}")
    if reply_prob is not None:
        bits.append(f"(expected reply ≈ {reply_prob:.2f})")
    if soon and not mid and not long:
        bits.append("— only a few are close to expiry, still saleable today")

    return " ".join(bits) + "."


def _group_reason_donate(
        donate_items: List[str],
        donate_target: Optional[str],
        meta: Dict[str, Dict[str, Any]],
) -> str:
    """Constructs a summary reason for the DONATE action."""
    if not donate_items:
        return "No items selected to donate."

    soon, mid, _ = _split_by_days(donate_items, meta)

    tgt = donate_target or "a local soup kitchen"
    bits = [f"donating {len(donate_items)} item(s) to {tgt}"]

    # Explain *why* these items are being donated.
    if soon:
        bits.append(f"because {len(soon)} expire ≤1 day")
    if mid and not soon:
        bits.append("to reduce overstock where market demand is uncertain today")

    return " ".join(bits) + "."


# ── Public API ─────────────────────────────────────────────────────────────────
def decide_actions() -> List[Dict[str, Any]]:
    """
    Main entry point for the final decision agent.
    This function orchestrates the entire process: loading data, selecting a recipe,
    determining targets, building per-ingredient decisions, generating summary reasons,
    and saving the output.
    """
    # --- 1. Load prerequisite data ---
    if not BEST_RECIPES_FILE.exists():
        raise FileNotFoundError(f"Missing {BEST_RECIPES_FILE}. Run the recipe agent first.")

    best = _load_json(BEST_RECIPES_FILE)
    if not isinstance(best, list) or not best:
        raise ValueError("best_matching_recipes.json must be a non-empty list of recipes.")

    # Sort recipes by rank as a stable starting point.
    best_sorted = sorted(best, key=lambda r: int(r.get("rank", 9999)))
    expiring_list, canon_by_norm = _expiring_universe()
    expiring_norms = {_norm(x) for x in expiring_list}

    # --- 2. Make the core recipe selection ---
    # Choose exactly ONE recipe using softmax sampling for human-like variability.
    selected = _select_one_recipe(best_sorted, expiring_norms, rng=_rng, temperature=HUMAN_TEMPERATURE)

    # --- 3. Determine SELL and DONATE targets ---
    sell_entry, sell_target, reply_prob = _pick_targets_and_reply_prob()

    donate_target = None
    if DONATION_FILE.exists():
        try:
            d = _load_json(DONATION_FILE)
            donate_target = (d.get("name") or "").strip() or None
        except Exception:
            donate_target = None  # Ignore errors, proceed without a specific target.

    # --- 4. Build per-ingredient decisions ---
    decisions = _build_decisions_single_recipe(
        expiring_universe=expiring_list,
        canon_by_norm=canon_by_norm,
        selected=selected,
        sell_target=sell_target,
        donate_target=donate_target,
        rng=_rng,
    )

    # --- 5. Save detailed output to file ---
    OUTPUT_FILE.parent.mkdir(parents=True, exist_ok=True)
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        json.dump(decisions, f, indent=2, ensure_ascii=False)


    # --- 6. Generate and display rich summary reasons ---
    cook_list = [d["item"] for d in decisions if d.get("action") == "COOK"]
    sell_list = [d["item"] for d in decisions if d.get("action") == "SELL"]
    donate_list = [d["item"] for d in decisions if d.get("action") == "DONATE"]

    meta_map = _expiring_meta_map()

    print("\n--- Final Decision Summary ---")
    print(f"COOK   ({len(cook_list)} items): ", ", ".join(cook_list) if cook_list else "none")
    print("  ↳ Reason:", _group_reason_cook(selected, cook_list, meta_map))

    print(f"SELL   ({len(sell_list)} items): ", ", ".join(sell_list) if sell_list else "none")
    print("  ↳ Reason:", _group_reason_sell(sell_list, sell_target, sell_entry, reply_prob, meta_map))

    print(f"DONATE ({len(donate_list)} items): ", ", ".join(donate_list) if donate_list else "none")
    print("  ↳ Reason:", _group_reason_donate(donate_list, donate_target, meta_map))
    print("----------------------------")

    return decisions


# Allow the script to be run directly for testing or standalone execution.
def main():
    """Main execution function when script is run directly."""
    try:
        decide_actions()
    except (FileNotFoundError, ValueError) as e:
        print(f"Error: {e}")
        # In a real application, you might exit with a non-zero status code.
        # import sys
        # sys.exit(1)


if __name__ == "__main__":
    main()